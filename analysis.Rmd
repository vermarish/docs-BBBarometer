---
title: "analysis"
author: "Rishabh Verma"
date: "7/30/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r}
library(tidyverse)
```


```{r}
data <- read_csv("data/data.csv")
```

```{r}
accelerometer <- data %>% 
  filter(type == 1) %>% 
  select(time, one, two, three) %>% 
  arrange(time)
  
pressure <- data %>% 
  filter(type == 6) %>% 
  select(time, one) %>% 
  arrange(time)

gyroscope <- data %>% 
  filter(type == 4) %>% 
  select(time, one, two, three) %>% 
  arrange(time)

uncalibrated_touch <- data %>% 
  filter(type == -27) %>% 
  select(time, one, two) %>% 
  arrange(time)
```

```{r}
accelerometer %>% select(time) %>% mutate(time = time %% 1e+12) %>% summary()

gyroscope %>% select(time) %>% mutate(time = time %% 1e+12) %>% summary()

pressure %>% select(time) %>% mutate(time = time %% 1e+12) %>% summary()

uncalibrated_touch %>% select(time) %>% mutate(time = time %% 1e+11) %>% summary()
```

Type -1: uptimeMillis (for touch events)
Type -2: elapsedRealtimeNanos (for sensor events)
Type -3: delta (for converting)

```{r}
uptimeMillisStart <- data %>% 
  filter(type == -1) %>% 
  select(time) %>% 
  slice(1) %>% 
  as.double()

uptimeMillisEnd <- data %>% 
  filter(type == -1) %>% 
  select(time) %>% 
  slice(2) %>% 
  as.double() 

elapsedRealtimeNanosStart <- data %>% 
  filter(type == -2) %>% 
  select(time) %>% 
  slice(1) %>% 
  as.double()

elapsedRealtimeNanosEnd <- data %>% 
  filter(type == -2) %>% 
  select(time) %>% 
  slice(2) %>% 
  as.double()
```

We'll convert everything from millis to nanos because the time of the touch input only needs to be approximate. 

The equation is `y = mx+b` where `y` is in nanos, `x` is in millis, `m` is the slope between them (10^6) and `b` is the y-intercept.

We can confirm the slope using the secant between the start and end points.

```{r}
m = (elapsedRealtimeNanosEnd - elapsedRealtimeNanosStart) / (uptimeMillisEnd - uptimeMillisStart)
(m - 1e+6)/1e+6*100 # percent error from 10^6
```

Then for a point $$(x_1,y_1)$$, I can calculate $$b = y_1 - mx_1$$
```{r}
b = elapsedRealtimeNanosEnd - m*uptimeMillisEnd
```

Now we can convert all of the time data for the touch input

```{r}
touch <- uncalibrated_touch %>% 
  mutate(time = m*time + b)

touch %>% select(time) %>% mutate(time = time %% 1e+12) %>% summary()
```
Now we're going to graph them together.

```{r}
first_touch = touch %>% 
  select(time) %>%
  min %>%
  as.double

last_touch = touch %>% 
  select(time) %>%
  max %>%
  as.double

range = last_touch - first_touch

## Pre-conditions not enforced:
## value = {'one', 'two', 'three'}
## 0 <= start < end <= 1
scatterplot <- function(data, value, start, end) {   
  # Use start/end to find a proportion of the touch input. Then find all sensor data within.
  # (Decided because multiple sensors are used, but there is only one touch dataset)
  open = range*start + first_touch
  close = range*end + first_touch
  
  graph <- data %>%
      filter(time > open & time < close)
  
  if (value == "one") {
    graph <- graph %>%
      ggplot(aes(x=time, y=one))
  } else if (value == "two") {
    graph <- graph %>%
      ggplot(aes(x=time, y=two))
  } else if (value == "three") {
    graph <- graph %>%
      ggplot(aes(x=time, y=three))
  }
  
  graph <- graph + geom_point()
  
  taps <- touch %>%
    filter(time > open & time < close)
  
  for (i in 1:as.integer(count(taps))) {
    time <- slice(taps, i)[1] %>% as.double()
    graph <- graph + geom_vline(xintercept = time)
  }
  return(graph)
}

```


Hold a phone horizontally while looking down. Consider pitch/yaw/roll from this orientation.

Vertical lines represent touch input. All touch inputs seem to line up with spikes in the gyro data, but spikes in the gyro data do NOT correspond with touch inputs. As such, we must use the pressure sensor to detect when a touch input occurs. Dataset one seems the most clean (I hypothesize this axis is pitch, because I would expect pitch to vary most with device inputs on the bottom of the screen.)

```{r}
scatterplot(gyroscope, "one", 0.03, 0.15)
scatterplot(gyroscope, "two", 0.03, 0.15)
scatterplot(gyroscope, "three", 0.03, 0.15)
```

```{r}
scatterplot(pressure, "one", 0.03, 0.15)
```

```{r}
p = 0.15
first = touch %>% select(time) %>% arrange(time) %>% slice(1) %>% as.double()
last = touch %>% select(time) %>% arrange(desc(time)) %>% slice(1) %>% as.double()
cutoff = first + p*(last-first)

graph <- gyroscope %>% 
  filter(time < cutoff) %>% 
  ggplot(aes(x = time, y = one)) +
  geom_point()

graph

taps = count(touch) %>% as.integer() * p

for (i in 1:taps) {
  time <- slice(touch, i)[1] %>% as.double()
  graph <- graph + geom_vline(xintercept = time)
}
graph
```
Alas!!! Progress! We can clearly see that the input events are marked by transients in the gyroscope data. There does unfortunately exist transients all over the place, so it's time for some processing. Let's try a low-pass filter, see if that does the trick.

```{r}
library(seewave)
```

```{r}
smooth_data <- gyroscope %>% 
  select(one) %>% 
  unlist() %>% 
  as.numeric()
  
freq = 1

one_smooth <- fir(smooth_data, f=freq, to=0.2) %>% as_tibble() %>% select(smoothed = V1)

one_smooth <- bind_cols(gyroscope, one_smooth)

graph <- one_smooth %>% 
  ggplot() +
  geom_point(aes(x = time, y = smoothed, color = "raw")) +
  geom_point(aes(x = time, y = one, color = "LPF"))


taps = dim(touch)[1]

for (i in 1:taps) {
  time <- slice(touch, i)[1] %>% as.double()
  graph <- graph + geom_vline(xintercept = time)
}

graph
```



A low-pass filter seems like it can cut the noise, but it cuts too much of the signal as well, and the peaks have become less apparent.

https://www.rdocumentation.org/packages/rwt/versions/1.0.0/topics/denoise

```{r}
library(rwt)
```

We're going to try wavelet denoising. This requires a power of 2 for the sample size.
```{r}
samples = 2^(floor(log2(count(gyroscope)))) %>% as.integer()
gyroscope <- gyroscope %>% slice(1:samples)

smooth_data <- gyroscope %>% 
  select(one) %>% 
  unlist() %>%
  unname()
  
h <- daubcqf(4)  # must be even

one_smooth <- denoise.dwt(smooth_data, h$h.0)[1] %>% as_tibble() %>% select(smoothed = xd)

one_smooth <- bind_cols(gyroscope, one_smooth)

graph <- one_smooth %>% 
  ggplot() +
  geom_point(aes(x = time, y = smoothed, color = "raw")) +
  geom_point(aes(x = time, y = one, color = "LPF"))


taps = dim(touch)[1]

for (i in 1:taps) {
  time <- slice(touch, i)[1] %>% as.double()
  graph <- graph + geom_vline(xintercept = time)
}

graph
```

```{r}
sig <- makesig(SIGNAL.DOPPLER)
h <- daubcqf(6)
ret.dwt <- denoise.dwt(sig$x, h$h.0)
```

```{r}
sig <- makesig(SIGNAL.LIN.CHIRP, 8)
h <- daubcqf(4)
L <- 2
ret.mdwt <- mdwt(sig$x, h$h.0, L)
```



```{r}
one_smooth <- fir(smooth_data, f=freq, to=0.2) %>% as_tibble() %>% select(smoothed = V1)

one_smooth <- bind_cols(gyroscope, one_smooth)

graph <- one_smooth %>% 
  ggplot() +
  geom_point(aes(x = time, y = smoothed, color = "raw")) +
  geom_point(aes(x = time, y = one, color = "LPF"))


taps = dim(touch)[1]

for (i in 1:taps) {
  time <- slice(touch, i)[1] %>% as.double()
  graph <- graph + geom_vline(xintercept = time)
}

graph
```